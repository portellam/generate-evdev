#!/bin/bash/env bash

#
# Filename:       generate-evdev.bash
# Description:    Parses input devices, updates system files,
#                 (optionally) restarts system service,
#                 and dumps output to file for use in QEMU VM XML.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

# TODO: create cronjob of last input.

# <params>
  declare -gA ALL_INPUT_EVENT_DICTIONARY KEYBOARD_INPUT_INDEX_DICTIONARY MOUSE_INPUT_INDEX_DICTIONARY # OTHER_INPUT_INDEX_DICTIONARY

  declare -r SCRIPT_NAME="$( basename ${0} )"
  declare -r SOURCE_DIR="/usr/local/etc/${SCRIPT_NAME}.d/"

  declare -ar FILE_WATERMARK=(
    "# Generated by 'portellam/${SCRIPT_NAME}'"
    "# WARNING: Any modifications to this file will be modified by '${SCRIPT_NAME}'"
    "#"
  )

  declare -gr PREFIX="${SCRIPT_NAME}: "

  # <summary>
  # Color coding
  # Reference URL: 'https://www.shellhacks.com/bash-colors'
  # </summary>
    declare -gr SET_COLOR_GREEN='\033[0;32m'
    declare -gr SET_COLOR_RED='\033[0;31m'
    declare -gr SET_COLOR_YELLOW='\033[0;33m'
    declare -gr RESET_COLOR='\033[0m'

  # <summary>Append output</summary>
    declare -gr PREFIX_ERROR="${PREFIX}${SET_COLOR_YELLOW}An error occurred:${RESET_COLOR} "
    declare -gr PREFIX_FAIL="${PREFIX}${SET_COLOR_RED}Failure:${RESET_COLOR} "
    declare -gr PREFIX_PASS="${PREFIX}${SET_COLOR_GREEN}Success:${RESET_COLOR} "

  # <summary>Execution flags</summary>
    declare -g DUMP_XML=false
    # declare -g EXCLUSIVE_KBM=true
    declare -g INCLUDE_HUGEPAGES=false
    declare -g OUTPUT_EVENT_PATHS=true
    declare -g OUTPUT_INPUT_PATHS=true
    declare -g RESTART_SERVICE=false
    declare -g SET_PERMISSIONS_TO_USER=false
    declare -g UNDO_CHANGES=false

  # <summary>Filenames</summary>
    declare -gr APPARMOR_QEMU_DEST_PATH="/etc/apparmor.d/local/abstractions/libvirt-qemu"
    declare -gr QEMU_DEST_PATH="/etc/libvirt/qemu.conf"
    declare -gr QEMU_SRC_PATH="${SOURCE_DIR}qemu.conf"
    declare -gr XML_DEST_PATH="${SOURCE_DIR}evdev.xml"

  declare -r LOGIN_USER=$( who am i | awk '{print $1}' )
# </params>

# <functions>
  function main
  {
    if ! is_sudo_user \
      || ! get_options "$@" \
      || ! get_evdev \
      || ! sort_evdev \
      || ! print_evdev \
      || ! prepare_files; then
      return 1
    fi

    if ! write_to_files; then
      print_fail_to_log "Could not generate Evdev setup."
      return 1
    fi

    print_pass_to_log "Generated Evdev setup."
  }

  # <summary>Usage</summary>
    function is_option_print_help
    {
      if [[ "${1}" != "-h" ]] \
        && [[ "${1}" != "--help" ]]; then
        return 1
      fi

      print_usage
      exit 1
    }

    function is_option_dump_xml
    {
      if [[ "${1}" != "--dump-xml" ]]; then
        return 1
      fi

      print_output_to_log "Dumping QEMU commandlines in XML format."
      DUMP_XML=true
    }

    function is_option_include_hugepages
    {
      if [[ "${1}" != "--hugepages" ]]; then
        return 1
      fi

      print_output_to_log "Adding Hugepages support."
      INCLUDE_HUGEPAGES=true
    }

    function is_option_include_only_keyboard_and_mouse
    {
      if [[ "${1}" != "--kbm-only" ]]; then
        return 1
      fi

      print_output_to_log "Whitelisting only Keyboard and Mouse devices."
      EXCLUSIVE_KBM=true
    }

    function is_option_output_event_paths
    {
      if [[ "${1}" != "--output-event-paths" ]]; then
        return 1
      fi

      OUTPUT_INPUT_PATHS=false
      print_output_to_log "Evdev output exclusive to Event paths."
    }

    function is_option_output_input_paths
    {
      if [[ "${1}" != "--output-input-paths" ]]; then
        return 1
      fi

      OUTPUT_EVENT_PATHS=false
      print_output_to_log "Evdev output exclusive to Input paths."
    }

    function is_option_restart_service
    {
      if [[ "${1}" != "--restart-service" ]]; then
        return 1
      fi

      RESTART_SERVICE=true
    }

    function is_option_set_permissions_to_user
    {
      if [[ "${1}" != "--set-user" ]]; then
        return 1
      fi

      print_output_to_log "Set user for Libvirt input devices: '${LOGIN_USER}'"
      RESTART_SERVICE=true
    }

    function is_option_undo_changes
    {
      if [[ "${1}" != "--undo-changes" ]]; then
        return 1
      fi

      print_output_to_log "Undoing changes."
      UNDO_CHANGES=true
    }

    function get_options
    {
      if [[ -z "$@" ]]; then
        return 0
      fi

      while [[ "${1}" != "" ]]; do
        parse_option $@ || exit 1     # <note>Do not change to "$@". Leave '$@' without quotes, as when this function is called by an outside script, the input will not shift correctly. Therefore, the given option will contain every option, bombing the function.</note>
        shift                         # <note>'shift' must remain in same scope to work.</note>
      done
    }

    function parse_option
    {
      if ! parse_this_option "$@"; then
        print_invalid_option "${1}"
      fi
    }

    function parse_this_option
    {
      # || is_option_include_only_keyboard_and_mouse "$@" \

      if is_option_print_help "$@" \
        || is_option_dump_xml "$@" \
        || is_option_include_hugepages "$@" \
        || is_option_output_event_paths "$@" \
        || is_option_output_input_paths "$@" \
        || is_option_restart_service "$@" \
        || is_option_set_permissions_to_user "$@" \
        || is_option_undo_changes "$@"; then
        return 0
      fi

      return 1
    }

    function pop_input_enum_if_last_option_contains_argument
    {
      while [[ ! -z "${1}" ]]; do
        shift
        (( args_counter++ ))
      done
    }

    function print_help
    {
      echo -e "Try 'sudo bash ${SCRIPT_NAME} --help' for usage."
    }

    function print_invalid_option
    {
      local -r output="Invalid option"

      if ! is_string "${1}" &> /dev/null; then
        print_error_to_log "${output}."
      else
        print_error_to_log "${output} '${1}'."
      fi

      print_help
      exit 1
    }

    function print_usage
    {
      IFS=$'\n'

      local -ar output=(
        "Usage:\tbash ${SCRIPT_NAME} [OPTION]"
        "Generates Evdev setup for Libvirt/QEMU virtual machines.\n"
        "  -h, --help\t\tPrint this help and exit."
        "  --dump-xml\t\tDump QEMU commandline (XML) output to file."
        "  --hugepages\t\tInclude Hugepages as device for Libvirt/QEMU."

        # NOTE: Given Evdev currently likely does not support devices outside of Keyboards and Mice, I will comment this out for now.
        # "  --kbm-only\t\tInclude only Keyboard and/or Mouse related devices in Evdev."

        "  --output-event-paths\tOutput Event device paths only."
        "  --output-input-paths\tOutput Input device paths only."
        "  --restart-service\tRestart Libvirtd system service after setup."
        "  --set-user\t\tSets user ownership of Libvirt Input devices to current user. Default is root."
        "  --undo-changes\tUndo changes; restore file backups."
      )

      echo -e "${output[*]}"
      unset IFS
    }

  # <summary>Loggers/summary>
    function print_error_to_log
    {
      echo -e "${PREFIX_ERROR}${1}" >&2
    }

    function print_fail_to_log
    {
      echo -e "${PREFIX_FAIL}${1}" >&2
    }

    function print_output_to_log
    {
      echo -e "${PREFIX}${1}" >&1
    }

    function print_pass_to_log
    {
      echo -e "${PREFIX_PASS}${1}" >&1
    }

  # <summary>Data-type validation</summary>
    function is_enum
    {
      local -n this_enum="${1}"

      if ! [[ "${#this_enum[@]}" -gt 0 ]]; then
        print_error_to_log "Invalid enum."
        return 1
      fi
    }

    function is_enum_not_empty
    {
      is_enum "${1}" || return 1
      local -n this_enum="${1}"

      for value in "${this_enum[@]}"; do
        if is_string "${value}" &> /dev/null; then
          return 0
        fi
      done

      print_error_to_log "Empty enum."
      return 1
    }

    function is_string
    {
      if [[ "${1}" == "" ]]; then
        print_error_to_log "Empty string."
        return 1
      fi
    }

  # <summary>File manipulation</summary>
    function write_ref_enum_to_file
    {
      if [[ -z "${2}" ]]; then
        print_error_to_log "Filename is not defined."
        return 1
      fi

      local -nr reference="${1}"
      local -r file="${2}"

      for line in "${reference[@]}"; do
        if ! sudo echo -e "${line}" >> "${file}"; then
          print_error_to_log "Could not append to file '${file}'."
          return 1
        fi
      done
    }

  # <summary>Business functions</summary>
    function get_evdev
    {
      for input_device in $( ls /dev/input/by-id ); do
        local line="$( ls -l /dev/input/by-id | grep --ignore-case "${input_device}" )"
        local event_device="$( echo "${line}" | awk 'END { print $NF }' | cut --delimiter '/' --fields 2 )"

        if [[ "${event_device}" == "${input_device}" ]]; then
          event_device=""
        fi

        ALL_INPUT_EVENT_DICTIONARY["${input_device}"]="${event_device}"
      done

      readonly ALL_INPUT_EVENT_DICTIONARY

      if ! is_enum_not_empty "ALL_INPUT_EVENT_DICTIONARY"; then
        print_error_to_log "No input devices found."
        return 1
      fi
    }

    function is_sudo_user
    {
      if [[ $( whoami ) != "root" ]]; then
        print_error_to_log "User is not sudo or root."
        return 1
      fi
    }

    function print_evdev
    {
      echo -e "Below is a list of referenced device IDs, and their actual device IDs (Event and Input devices, respectively)."
      echo -e "\nSupported?\tEvent ID\tInput ID"

      for input_device in "${!ALL_INPUT_EVENT_DICTIONARY[@]}"; do
        local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"
        local device_is_not_supported=false
        local supported_string="No"

        if [[ -z "${event_device}" ]]; then
          event_device="N/A"
        fi

        # NOTE: Given Evdev currently likely does not support devices outside of Keyboards and Mice, this will highlight incompatible devices.
        if ! is_string "${KEYBOARD_INPUT_INDEX_DICTIONARY["${input_device}"]}" &> /dev/null \
          && ! is_string "${MOUSE_INPUT_INDEX_DICTIONARY["${input_device}"]}" &> /dev/null; then
          device_is_not_supported=true
        fi

        if "${device_is_not_supported}"; then
          supported_string="${SET_COLOR_RED}${supported_string}${RESET_COLOR}"

        else
          supported_string="${SET_COLOR_GREEN}Yes${RESET_COLOR}"
        fi

        echo -en "${supported_string}\t\t${event_device}\t\t${input_device}\n"
      done

      echo -e "\nYou may copy the following XML output, and append to a virtual machine's XML file.\n"

      local -r qemu_begin_tag="<qemu:commandline>"
      local -r qemu_end_tag="</qemu:commandline>"
      local -r qemu_object="\t<qemu:arg value="-object"/>"

      echo "${qemu_begin_tag}"

      if "${DUMP_XML}"; then
        if ! sudo rm --force "${XML_DEST_PATH}" &> /dev/null; then
          print_error_to_log "Could not delete XML file."
        fi

        dump_xml_file_contents+=( "${qemu_begin_tag}" )
      fi

      local -i x=1
      local -i y=2

      for input_device in "${!KEYBOARD_INPUT_INDEX_DICTIONARY[@]}"; do
        local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"
        local event_device_output="\t<qemu:arg value="input-linux,id=kbd${x},evdev=/dev/input/${event_device},grab_all=on,repeat=on"/>"
        local input_device_output="\t<qemu:arg value="input-linux,id=kbd${y},evdev=/dev/input/by-id/${input_device},grab_all=on,repeat=on"/>"

        if "${OUTPUT_EVENT_PATHS}"; then
          echo -e "${qemu_object}\n${event_device_output}"

          if "${DUMP_XML}"; then
          dump_xml_file_contents+=(  )
            dump_xml_file_contents+=( "${qemu_object}" "${event_device_output}" )
          fi
        fi

        if "${OUTPUT_INPUT_PATHS}"; then
          echo -e "${qemu_object}\n${input_device_output}"

          if "${DUMP_XML}"; then
            dump_xml_file_contents+=( "${qemu_object}" "${input_device_output}" )
          fi
        fi

        x=$(( x + 2 ))
        y=$(( y + 2 ))
      done

      local -i x=1
      local -i y=2

      for input_device in "${!MOUSE_INPUT_INDEX_DICTIONARY[@]}"; do
        local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"
        local event_device_output="\t<qemu:arg value="input-linux,id=mouse${x},evdev=/dev/input/${event_device}"/>"
        local input_device_output="\t<qemu:arg value="input-linux,id=mouse${y},evdev=/dev/input/by-id/${input_device}"/>"

        if "${OUTPUT_EVENT_PATHS}"; then
          echo -e "${qemu_object}\n${event_device_output}"

          if "${DUMP_XML}"; then
          dump_xml_file_contents+=(  )
            dump_xml_file_contents+=( "${qemu_object}" "${event_device_output}" )
          fi
        fi

        if "${OUTPUT_INPUT_PATHS}"; then
          echo -e "${qemu_object}\n${input_device_output}"

          if "${DUMP_XML}"; then
            dump_xml_file_contents+=( "${qemu_object}" "${input_device_output}" )
          fi
        fi

        x=$(( x + 2 ))
        y=$(( y + 2 ))
      done

      # local -i x=1
      # local -i y=2

      # NOTE: Given Evdev currently likely does not support devices outside of Keyboards and Mice, I will comment this out for now.
      # if ! "${EXCLUSIVE_KBM}"; then
      #   for input_device in "${!OTHER_INPUT_INDEX_DICTIONARY[@]}"; do
      #     local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"
      #     local event_device_output="\t<qemu:arg value="input-linux,id=PLACEHOLDER${x},evdev=/dev/input/${event_device}"/>"
      #     local input_device_output="\t<qemu:arg value="input-linux,id=PLACEHOLDER${y},evdev=/dev/input/by-id/${input_device}"/>"

      #     if "${OUTPUT_EVENT_PATHS}"; then
      #       echo -e "${qemu_object}\n${event_device_output}"

      #       if "${DUMP_XML}"; then
      #       dump_xml_file_contents+=(  )
      #         dump_xml_file_contents+=( "${qemu_object}" "${event_device_output}" )
      #       fi
      #     fi

      #     if "${OUTPUT_INPUT_PATHS}"; then
      #       echo -e "${qemu_object}\n${input_device_output}"

      #       if "${DUMP_XML}"; then
      #         dump_xml_file_contents+=( "${qemu_object}" "${input_device_output}" )
      #       fi
      #     fi

      #     x=$(( x + 2 ))
      #     y=$(( y + 2 ))
      #   done
      # fi

      echo -e "${qemu_end_tag}\n"

      if "${DUMP_XML}"; then
        dump_xml_file_contents+=( "${qemu_end_tag}" )

        if ! write_ref_enum_to_file "dump_xml_file_contents" "${XML_DEST_PATH}"; then
          print_error_to_log "Could not dump XML output to file '${XML_DEST_PATH}'."
          return 1
        fi

        print_pass_to_log "Dumped XML output to file '${XML_DEST_PATH}'."
      fi
    }

    function prepare_files
    {
      if ! rm --force "${APPARMOR_QEMU_DEST_PATH}"; then
        print_error_to_log "Could not delete file '${APPARMOR_QEMU_DEST_PATH}'"
        return 1
      fi

      local -r file1_backup="${QEMU_DEST_PATH}.old"

      if "${UNDO_CHANGES}"; then
        if [[ -e "${file1_backup}" ]] \
          && ! cp "${file1_backup}" "${QEMU_DEST_PATH}"; then
          print_error_to_log "Could not restore file '${QEMU_DEST_PATH}'"
          return 1
        fi

        return 0
      fi

      if [[ -e "${QEMU_DEST_PATH}" ]] \
        && ! cp "${QEMU_DEST_PATH}" "${file1_backup}"; then
        print_error_to_log "Could not backup file '${QEMU_DEST_PATH}'"
        return 1
      fi

      if ! cp "${QEMU_SRC_PATH}" "${QEMU_DEST_PATH}"; then
        print_error_to_log "Could not copy QEMU source file to destination."
        return 1
      fi
    }

    function restart_service
    {
      if ! "${RESTART_SERVICE}"; then
        return 0
      fi

      if ! systemctl restart libvirtd &> /dev/null; then
        print_error_to_log "Could not restart system service 'libvirtd.'"
        return 1
      fi
    }

    function sort_evdev
    {
      local -A partial_input_device_dictionary
      local -i total_keyboard_devices=0
      local -i total_mouse_devices=0
      # local -i total_other_devices=0

      for input_device in "${!ALL_INPUT_EVENT_DICTIONARY[@]}"; do
        local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"
        local event_id=$( echo "${event_device}" | grep --only-matching --extended-regexp '[0-9]+' )

        local is_keyboard=false
        local is_mouse=false

        local input_device_partial_basename=""
        local input_device_match_suffix="event-if"
        local input_device_partial_suffix="event-"
        local partial_input_device="${input_device}"

        if $( echo "${input_device}" | grep --ignore-case --regexp="kbd" &> /dev/null ); then
          is_keyboard=true
        fi

        if ! "${is_keyboard}" \
          && $( echo "${input_device}" | grep --ignore-case --regexp="mouse" &> /dev/null ); then
          is_mouse=true
        fi

        if ! "${is_keyboard}" \
          && ! "${is_mouse}" \
          && $( echo "${input_device}" | grep "${input_device_match_suffix}"* &> /dev/null ); then
          partial_input_device="${input_device%${input_device_match_suffix}*}"
          partial_input_device="${partial_input_device}${input_device_partial_suffix}"
          partial_input_device_dictionary["${input_device}"]="${partial_input_device}"
        fi

        case true in
          "${is_keyboard}" )
            total_keyboard_devices=$(( total_keyboard_devices + 1 ))
            KEYBOARD_INPUT_INDEX_DICTIONARY["${input_device}"]="${total_keyboard_devices}" ;;

          "${is_mouse}" )
            total_mouse_devices=$(( total_mouse_devices + 1 ))
            MOUSE_INPUT_INDEX_DICTIONARY["${input_device}"]="${total_mouse_devices}" ;;

          # NOTE: Given Evdev currently likely does not support devices outside of Keyboards and Mice, I will comment this out for now.
          # * )
          #   total_other_devices=$(( total_other_devices + 1 ))
          #   OTHER_INPUT_INDEX_DICTIONARY["${input_device}"]="${total_other_devices}" ;;
        esac
      done

      for input_device in "${!partial_input_device_dictionary[@]}"; do
        local is_keyboard=false
        local is_mouse=false

        local partial_input_device="${partial_input_device_dictionary["${input_device}"]}"
        local keyboard_input_device="${partial_input_device}kbd"
        local mouse_input_device="${partial_input_device}mouse"

        if is_string "${KEYBOARD_INPUT_INDEX_DICTIONARY["${keyboard_input_device}"]}" &> /dev/null; then
          total_keyboard_devices=$(( total_keyboard_devices + 1 ))
          KEYBOARD_INPUT_INDEX_DICTIONARY["${input_device}"]="${total_keyboard_devices}"
          continue
        fi

        if is_string "${KEYBOARD_INPUT_INDEX_DICTIONARY["${mouse_input_device}"]}" &> /dev/null; then
          total_mouse_devices=$(( total_mouse_devices + 1 ))
          MOUSE_INPUT_INDEX_DICTIONARY["${input_device}"]="${total_mouse_devices}"
          continue
        fi

        # NOTE: Given Evdev currently likely does not support devices outside of Keyboards and Mice, I will comment this out for now.
        # total_other_devices=$(( total_other_devices + 1 ))
        # OTHER_INPUT_INDEX_DICTIONARY["${input_device}"]="${total_other_devices}" ;;
      done

      readonly KEYBOARD_INPUT_INDEX_DICTIONARY MOUSE_INPUT_INDEX_DICTIONARY # OTHER_INPUT_INDEX_DICTIONARY

      # if ! "${EXCLUSIVE_KBM}"; then
      #   return 0
      # fi

      if ! is_enum_not_empty "KEYBOARD_INPUT_INDEX_DICTIONARY"; then
        print_error_to_log "No Keyboard device(s) found."
        return 1
      fi

      if ! is_enum_not_empty "MOUSE_INPUT_INDEX_DICTIONARY"; then
        print_error_to_log "No Mouse device(s) found."
        return 1
      fi
    }

    function write_to_files
    {
      local -a file1_output=(
        ""
        "${FILE_WATERMARK[@]}"
        ""
        "### User permissions ###"
      )

      local -a file2_output=( "${FILE_WATERMARK[@]}" )

      if "${SET_PERMISSIONS_TO_USER}"; then
        file1_output+=(
          "user = \"${LOGIN_USER}\""
        )
      else
        file1_output+=(
          "user = \"root\""
        )
      fi

      file1_output+=(
        ""
        "### Hugepages ###"
      )

      file2_output+=(
          ""
          "# Hugepages"
        )

      if "${UNDO_CHANGES}" \
        || ! "${INCLUDE_HUGEPAGES}"; then
        file1_output+=(
          "#hugetlbfs_mount = \"/dev/hugepages\""
        )

        file2_output+=(
          "#/dev/hugepages rw,"
        )
      else
        file1_output+=(
          "hugetlbfs_mount = \"/dev/hugepages\""
        )

        file2_output+=(
          "/dev/hugepages rw,"
        )
      fi

      local -a file1_cgroups_output

      if ! "${UNDO_CHANGES}"; then
        for input_device in ${!KEYBOARD_INPUT_INDEX_DICTIONARY[@]}; do
          local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"

          if "${OUTPUT_EVENT_PATHS}"; then
            file1_cgroups_output+=( "    \"/dev/input/${event_device}\"," )
          fi

          if "${OUTPUT_INPUT_PATHS}"; then
            file1_cgroups_output+=( "    \"/dev/input/by-id/${input_device}\"," )
          fi
        done

        for input_device in ${!MOUSE_INPUT_INDEX_DICTIONARY[@]}; do
          local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"

          if "${OUTPUT_EVENT_PATHS}"; then
            file1_cgroups_output+=( "    \"/dev/input/${event_device}\"," )
          fi

          if "${OUTPUT_INPUT_PATHS}"; then
            file1_cgroups_output+=( "    \"/dev/input/by-id/${input_device}\"," )
          fi
        done

        # for input_device in ${!OTHER_INPUT_INDEX_DICTIONARY[@]}; do
        #   local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"

        #   if "${OUTPUT_EVENT_PATHS}"; then
        #     file1_cgroups_output+=( "    \"/dev/input/${event_device}\"," )
        #   fi

        #   if "${OUTPUT_INPUT_PATHS}"; then
        #     file1_cgroups_output+=( "    \"/dev/input/by-id/${input_device}\"," )
        #   fi
        # done
      fi

      file1_output+=(
        ""
        "### Devices ###"
        "cgroup_device_acl = ["
      )

      file2_output+=(
          ""
          "# Evdev"
      )

      local -a file1_default_cgroups_output=(
        "    \"/dev/null\", \"/dev/full\", \"/dev/zero\","
        "    \"/dev/random\", \"/dev/urandom\","
        "    \"/dev/ptmx\", \"/dev/kvm\","
        "    \"/dev/rtc\", \"/dev/hpet\""
      )

      if ! "${UNDO_CHANGES}"; then
        file1_output+=(
          "${file1_cgroups_output[@]}"
          "${file1_default_cgroups_output[@]}"
          "]"
        )

        file2_output+=(
          "/dev/input/* rw,"
          "/dev/input/by-id/* rw,"
        )
      else
        file1_output+=(
          "${file1_default_cgroups_output[@]}"
          "]"
        )

        file2_output+=(
          "#/dev/input/* rw,"
          "#/dev/input/by-id/* rw,"
        )
      fi

      file1_output+=(
        ""
        "nvram = ["
        "    \"/usr/share/OVMF/OVMF_CODE.fd:/usr/share/OVMF/OVMF_VARS.fd\","
        "    \"/usr/share/OVMF/OVMF_CODE.secboot.fd:/usr/share/OVMF/OVMF_VARS.fd\","
        "    \"/usr/share/AAVMF/AAVMF_CODE.fd:/usr/share/AAVMF/AAVMF_VARS.fd\","
        "    \"/usr/share/AAVMF/AAVMF32_CODE.fd:/usr/share/AAVMF/AAVMF32_VARS.fd\""
        "]"
      )

      if ! write_ref_enum_to_file "file1_output" "${QEMU_DEST_PATH}" \
        || ! write_ref_enum_to_file "file2_output" "${APPARMOR_QEMU_DEST_PATH}" \
        || ! restart_service; then
        return 1
      fi
    }
# </functions>

main "$@"
exit "${?}"