#!/bin/bash/env bash

#
# Filename:       generate-evdev.bash
# Description:    Parses input devices, updates system files,
#                 (optionally) restarts system service,
#                 and dumps output to file for use in QEMU VM XML.
# Author(s):      Alex Portell <github.com/portellam>
# Maintainer(s):  Alex Portell <github.com/portellam>
#

# <params>
  declare -gA ALL_INPUT_EVENT_DICTIONARY KEYBOARD_INPUT_INDEX_DICTIONARY MOUSE_INPUT_INDEX_DICTIONARY # OTHER_INPUT_INDEX_DICTIONARY

  declare -r SCRIPT_NAME="$( basename ${0} )"
  declare -r REPO_NAME="generate-evdev"

  declare -ar FILE_WATERMARK=(
    "# Generated by 'portellam/${REPO_NAME}'"
    "# WARNING: Any modifications to this file will be modified by '${REPO_NAME}'"
    "#"
  )

  declare -gr PREFIX="${SCRIPT_NAME}: "

  # <summary>
  # Color coding
  # Reference URL: 'https://www.shellhacks.com/bash-colors'
  # </summary>
    declare -gr SET_COLOR_GREEN='\033[0;32m'
    declare -gr SET_COLOR_RED='\033[0;31m'
    declare -gr SET_COLOR_YELLOW='\033[0;33m'
    declare -gr RESET_COLOR='\033[0m'

  # <summary>Append output</summary>
    declare -gr PREFIX_ERROR="${PREFIX}${SET_COLOR_YELLOW}An error occurred:${RESET_COLOR} "
    declare -gr PREFIX_FAIL="${PREFIX}${SET_COLOR_RED}Failure:${RESET_COLOR} "
    declare -gr PREFIX_PASS="${PREFIX}${SET_COLOR_GREEN}Success:${RESET_COLOR} "

  # <summary>Execution flags</summary>
    declare -g DUMP_XML=false
    # declare -g EXCLUSIVE_KBM=true
    declare -g INCLUDE_HUGEPAGES=false
    declare -g OUTPUT_EVENT_PATHS=false
    declare -g RESTART_SERVICE=false
    declare -g SET_PERMISSIONS_TO_USER=false
    declare -g UNDO_CHANGES=false

  # <summary>Filenames</summary>
    declare -gr APPARMOR_QEMU_DEST_PATH="/etc/apparmor.d/local/abstractions/libvirt-qemu"
    declare -gr QEMU_DEST_PATH="/etc/libvirt/qemu.conf"
    declare -gr QEMU_SRC_PATH=$( dirname "${0}" )"/qemu.conf"

  declare -r LOGIN_USER=$( who am i | awk '{print $1}' )
# </params>

# <functions>
  # <summary>Usage</summary>
    function is_option_print_help
    {
      if [[ "${1}" == "-h" ]] \
        || [[ "${1}" == "--help" ]]; then
        print_usage
        exit 1
      fi
    }

    function is_option_dump_xml
    {
      if [[ "${1}" == "--dump-xml" ]]; then
        print_output_to_log "Dumping QEMU commandlines in XML format."
        DUMP_XML=true
      fi
    }

    function is_option_include_hugepages
    {
      if [[ "${1}" == "--hugepages" ]]; then
        print_output_to_log "Adding Hugepages support."
        INCLUDE_HUGEPAGES=true
      fi
    }

    # function is_option_include_only_keyboard_and_mouse
    # {
    #   if [[ "${1}" == "--kbm-only" ]]; then
    #     EXCLUSIVE_KBM=true
    #   fi
    # }

    function is_option_output_event_paths
    {
      if [[ "${1}" == "--output-event-paths" ]]; then
        OUTPUT_EVENT_PATHS=true
        print_output_to_log "Evdev output exclusive to Event paths."
      fi
    }

    function is_option_restart_service
    {
      if [[ "${1}" == "--restart-service" ]]; then
        RESTART_SERVICE=true
      fi
    }

    function is_option_set_permissions_to_user
    {
      if [[ "${1}" == "--set-user" ]]; then
        print_output_to_log "Set user for Libvirt input devices: '$LOGIN_USER'"
        RESTART_SERVICE=true
      fi
    }

    function is_option_undo_changes
    {
      if [[ "${1}" == "--undo-changes" ]]; then
        print_output_to_log "Undoing changes."
        UNDO_CHANGES=true
      fi
    }

    function get_options
    {
      if [[ -z "$@" ]]; then
        return 0
      fi

      while [[ "${1}" != "" ]]; do
        parse_option "$@" || exit 1
        shift                         # <note>'shift' must remain in same scope to work.</note>
      done
    }

    function parse_option
    {
      if ! parse_this_option "$@"; then
        print_invalid_option "${1}"
      fi
    }

    function parse_this_option
    {
      is_option_print_help "$@" && return 0
      is_option_dump_xml "$@" && return 0
      is_option_include_hugepages "$@" && return 0
      # is_option_include_only_keyboard_and_mouse "$@" && return 0
      is_option_output_event_paths "$@" && return 0
      is_option_restart_service "$@" && return 0
      is_option_set_permissions_to_user "$@" && return 0
      is_option_undo_changes "$@" && return 0
      return 1

    function pop_input_enum_if_last_option_contains_argument
    {
      while [[ ! -z "${1}" ]]; do
        shift
        (( args_counter++ ))
      done
    }

    function print_help
    {
      echo -e "Try 'sudo bash ${SCRIPT_NAME} --help' for usage."
    }

    function print_invalid_option
    {
      local -r output="Invalid option"

      if ! is_string "${1}" &> /dev/null; then
        print_error_to_log "${output}."
      else
        print_error_to_log "${output} '${1}'."
      fi

      print_help
      exit 1
    }

    function print_usage
    {
      IFS=$'\n'

      local -ar output=(
        "Usage:\tbash ${SCRIPT_NAME} [OPTION]"
        "Generates Evdev setup for Libvirt/QEMU virtual machines.\n"
        "  -h, --help\t\tPrint this help and exit."
        "  --dump-xml\t\tDump QEMU commandline (XML) output to file."
        "  --hugepages\t\tInclude Hugepages as device for Libvirt/QEMU."

        # NOTE: Given Evdev currently likely does not support devices outside of Keyboards and Mice, I will comment this out for now.
        # "  --kbm-only\t\tInclude only Keyboard and/or Mouse related devices in Evdev."

        "  --output-event-paths\tOutput Event device paths, instead of Input device paths."
        "  --restart-service\tRestart Libvirtd system service after setup."
        "  --set-user\tSets user ownership of Libvirt Input devices to current user. Default is root."
        "  --undo-changes\tUndo changes; restore file backups."
      )

      echo -e "${output[*]}"
      unset IFS
    }

  # <summary>Loggers/summary>
    function print_error_to_log
    {
        echo -e "${PREFIX_ERROR}${1}" >&2
    }

    function print_fail_to_log
    {
      echo -e "${PREFIX_FAIL}${1}" >&2
    }

    function print_output_to_log
    {
      echo -e "${PREFIX_PROMPT}${1}" >&1
    }

  # <summary>Data-type validation</summary>
    function is_enum
    {
      local -n this_enum="${1}"

      if ! [[ "${#this_enum[@]}" -gt 0 ]]; then
        print_error_to_log "Invalid enum."
        return 1
      fi
    }

    function is_enum_not_empty
    {
      is_enum "${1}" || return 1
      local -n this_enum="${1}"

      for value in "${this_enum[@]}"; do
        if is_string "${value}" &> /dev/null; then
          return 0
        fi
      done

      print_error_to_log "Empty enum."
      return 1
    }

    function is_string
    {
      if [[ "${1}" == "" ]]; then
        print_error_to_log "Empty string."
        return 1
      fi
    }

  # <summary>File manipulation</summary>
    function write_ref_enum_to_file
    {
      if [[ -z "${2}" ]]; then
        print_error_to_log "Filename is not defined."
        return 1
      fi

      local -nr reference="${1}"
      local -r file="${2}"

      for line in "${reference[@]}"; do
        if ! sudo echo -e "${line}" >> "${file}"; then
          print_error_to_log "Could not append to file '${file}'."
          return 1
        fi
      done
    }

  # <summary>Business functions</summary>
    function get_evdev
    {
      for input_device in $( ls /dev/input/by-id ); do
        local line="$( ls -l /dev/input/by-id | grep --ignore-case "${input_device}" )"
        local event_device="$( echo "${line}" | awk 'END { print $NF }' | cut --delimiter '/' --fields 2 )"

        if [[ "${event_device}" == "${input_device}" ]]; then
          event_device=""
        fi

        ALL_INPUT_EVENT_DICTIONARY["${input_device}"]="${event_device}"
      done

      readonly ALL_INPUT_EVENT_DICTIONARY

      if ! is_enum_not_empty "ALL_INPUT_EVENT_DICTIONARY"; then
        print_error_to_log "No input devices found."
        return 1
      fi
    }

    function print_evdev
    {
      echo -e "${PREFIX}Below is a list of referenced device IDs, and their actual device IDs (Event and Input devices, respectively)."
      echo -e "\nSupported?\tEvent ID\tInput ID"

      for input_device in "${!ALL_INPUT_EVENT_DICTIONARY[@]}"; do
        local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"
        local device_is_not_supported=false
        local supported_string="No"

        if [[ -z "${event_device}" ]]; then
          event_device="N/A"
        fi

        # NOTE: Given Evdev currently likely does not support devices outside of Keyboards and Mice, this will highlight incompatible devices.
        if ! is_string "${KEYBOARD_INPUT_INDEX_DICTIONARY["${input_device}"]}" &> /dev/null \
          && ! is_string "${MOUSE_INPUT_INDEX_DICTIONARY["${input_device}"]}" &> /dev/null; then
          device_is_not_supported=true
        fi

        if "${device_is_not_supported}"; then
          supported_string="${SET_COLOR_RED}${supported_string}${RESET_COLOR}"

        else
          supported_string="${SET_COLOR_GREEN}Yes${RESET_COLOR}"
        fi

        echo -en "${supported_string}\t\t${event_device}\t\t${input_device}\n"
      done

      echo -e "\n${PREFIX}You may copy the following XML output, and append to a virtual machine's XML file.\n"
      echo -e "<qemu:commandline>"

      for input_device in "${!KEYBOARD_INPUT_INDEX_DICTIONARY[@]}"; do
        local -i index="${KEYBOARD_INPUT_INDEX_DICTIONARY["${input_device}"]}"
        local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"
        echo -e "\t<qemu:arg value="-object"/>"

        if "${OUTPUT_EVENT_PATHS}"; then
          echo -e "\t<qemu:arg value="input-linux,id=kbd${index},evdev=/dev/input/${event_device},grab_all=on,repeat=on"/>"
        else
          echo -e "\t<qemu:arg value="input-linux,id=kbd${index},evdev=/dev/input/by-id/${input_device},grab_all=on,repeat=on"/>"
        fi
      done

      for input_device in "${!MOUSE_INPUT_INDEX_DICTIONARY[@]}"; do
        local -i index="${MOUSE_INPUT_INDEX_DICTIONARY["${input_device}"]}"
        local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"
        echo -e "\t<qemu:arg value="-object"/>"

        if "${OUTPUT_EVENT_PATHS}"; then
          echo -e "\t<qemu:arg value="input-linux,id=mouse${index},evdev=/dev/input/${event_device}"/>"
        else
          echo -e "\t<qemu:arg value="input-linux,id=mouse${index},evdev=/dev/input/by-id/${input_device}"/>"
        fi
      done

      # # NOTE: Given Evdev currently likely does not support devices outside of Keyboards and Mice, I will comment this out for now.
      # if ! "${EXCLUSIVE_KBM}"; then
      #   for input_device in "${!OTHER_INPUT_INDEX_DICTIONARY[@]}"; do
      #     local -i index="${OTHER_INPUT_INDEX_DICTIONARY["${input_device}"]}"
      #     # echo -e "\t<qemu:arg value="-object"/>"

      #     # TODO: Replace "PLACEHOLDER" with appropriate device ID.
      #       if "${OUTPUT_EVENT_PATHS}"; then
      #         echo -e "\t<qemu:arg value="input-linux,id=PLACEHOLDER${index},evdev=/dev/input/${event_device}"/>"
      #       else
      #         echo -e "\t<qemu:arg value="input-linux,id=PLACEHOLDER${index},evdev=/dev/input/by-id/${input_device}"/>"
      #       fi
      #   done
      # fi

      echo -e "/<qemu:commandline>"
    }

    function prepare_files
    {
      if ! rm --force "${APPARMOR_QEMU_DEST_PATH}"; then
        print_error_to_log "Could not delete file '${APPARMOR_QEMU_DEST_PATH}'"
        return 1
      fi

      local -r file1_backup="${QEMU_DEST_PATH}.old"

      if "${UNDO_CHANGES}"; then
        if [[ -e "${file1_backup}" ]] \
          && ! cp "${file1_backup}" "${QEMU_DEST_PATH}"; then
          print_error_to_log "Could not restore file '${QEMU_DEST_PATH}'"
          return 1
        fi

        return 0
      fi

      if [[ -e "${QEMU_DEST_PATH}" ]] \
        && ! cp "${QEMU_DEST_PATH}" "${file1_backup}"; then
        print_error_to_log "Could not backup file '${QEMU_DEST_PATH}'"
        return 1
      fi

      if ! cp "${QEMU_SRC_PATH}" "${QEMU_DEST_PATH}"; then
        print_error_to_log "Could not copy QEMU source file to destination."
        return 1
      fi
    }

    function restart_service
    {
      if ! "${RESTART_SERVICE}"; then
        return 0
      fi

      if ! systemctl restart libvirtd &> /dev/null; then
        print_error_to_log "Could not restart system service 'libvirtd.'"
        return 1
      fi
    }

    function sort_evdev
    {
      local -A partial_input_device_dictionary
      local -i total_keyboard_devices=0
      local -i total_mouse_devices=0
      # local -i total_other_devices=0

      for input_device in "${!ALL_INPUT_EVENT_DICTIONARY[@]}"; do
        local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"
        local event_id=$( echo "${event_device}" | grep --only-matching --extended-regexp '[0-9]+' )

        local is_keyboard=false
        local is_mouse=false

        local input_device_partial_basename=""
        local input_device_match_suffix="event-if"
        local input_device_partial_suffix="event-"
        local partial_input_device="${input_device}"

        if $( echo "${input_device}" | grep --ignore-case --regexp="kbd" &> /dev/null ); then
          is_keyboard=true
        fi

        if ! "${is_keyboard}" \
          && $( echo "${input_device}" | grep --ignore-case --regexp="mouse" &> /dev/null ); then
          is_mouse=true
        fi

        if ! "${is_keyboard}" \
          && ! "${is_mouse}" \
          && $( echo "${input_device}" | grep "${input_device_match_suffix}"* &> /dev/null ); then
          partial_input_device="${input_device%${input_device_match_suffix}*}"
          partial_input_device="${partial_input_device}${input_device_partial_suffix}"
          partial_input_device_dictionary["${input_device}"]="${partial_input_device}"
        fi

        case true in
          "${is_keyboard}" )
            total_keyboard_devices=$(( total_keyboard_devices + 1 ))
            KEYBOARD_INPUT_INDEX_DICTIONARY["${input_device}"]="${total_keyboard_devices}" ;;

          "${is_mouse}" )
            total_mouse_devices=$(( total_mouse_devices + 1 ))
            MOUSE_INPUT_INDEX_DICTIONARY["${input_device}"]="${total_mouse_devices}" ;;

          # NOTE: Given Evdev currently likely does not support devices outside of Keyboards and Mice, I will comment this out for now.
          # * )
          #   total_other_devices=$(( total_other_devices + 1 ))
          #   OTHER_INPUT_INDEX_DICTIONARY["${input_device}"]="${total_other_devices}" ;;
        esac
      done

      for input_device in "${!partial_input_device_dictionary[@]}"; do
        local is_keyboard=false
        local is_mouse=false

        local partial_input_device="${partial_input_device_dictionary["${input_device}"]}"
        local keyboard_input_device="${partial_input_device}kbd"
        local mouse_input_device="${partial_input_device}mouse"

        if is_string "${KEYBOARD_INPUT_INDEX_DICTIONARY["${keyboard_input_device}"]}" &> /dev/null; then
          total_keyboard_devices=$(( total_keyboard_devices + 1 ))
          KEYBOARD_INPUT_INDEX_DICTIONARY["${input_device}"]="${total_keyboard_devices}"
          continue
        fi

        if is_string "${KEYBOARD_INPUT_INDEX_DICTIONARY["${mouse_input_device}"]}" &> /dev/null; then
          total_mouse_devices=$(( total_mouse_devices + 1 ))
          MOUSE_INPUT_INDEX_DICTIONARY["${input_device}"]="${total_mouse_devices}"
          continue
        fi

        # NOTE: Given Evdev currently likely does not support devices outside of Keyboards and Mice, I will comment this out for now.
        # total_other_devices=$(( total_other_devices + 1 ))
        # OTHER_INPUT_INDEX_DICTIONARY["${input_device}"]="${total_other_devices}" ;;
      done

      readonly KEYBOARD_INPUT_INDEX_DICTIONARY MOUSE_INPUT_INDEX_DICTIONARY # OTHER_INPUT_INDEX_DICTIONARY

      # if ! "${EXCLUSIVE_KBM}"; then
      #   return 0
      # fi

      # echo -e "${PREFIX}Whitelisting only Keyboard and Mouse devices."

      if ! is_enum_not_empty "KEYBOARD_INPUT_INDEX_DICTIONARY"; then
        print_error_to_log "No Keyboard device(s) found."
        return 1
      fi

      if ! is_enum_not_empty "MOUSE_INPUT_INDEX_DICTIONARY"; then
        print_error_to_log "No Mouse device(s) found."
        return 1
      fi
    }

    function write_to_files
    {
      local -a file1_output=(
        ""
        "${FILE_WATERMARK[@]}"
        ""
        "### User permissions ###"
      )

      local -a file2_output=( "${FILE_WATERMARK[@]}" )

      if "${SET_PERMISSIONS_TO_USER}"; then
        file1_output+=(
          "user = \"${LOGIN_USER}\""
        )
      else
        file1_output+=(
          "user = \"root\""
        )
      fi

      file1_output+=(
        ""
        "### Hugepages ###"
      )

      file2_output+=(
          ""
          "# Hugepages"
        )

      if "${UNDO_CHANGES}" \
        || ! "${INCLUDE_HUGEPAGES}"; then
        file1_output+=(
          "#hugetlbfs_mount = \"/dev/hugepages\""
        )

        file2_output+=(
        )
      else
        file1_output+=(
          "hugetlbfs_mount = \"/dev/hugepages\""
        )

        file2_output+=(
          "/dev/hugepages rw,"
        )
      fi

      local -a file1_cgroups_output

      if ! "${UNDO_CHANGES}"; then
        for input_device in ${!KEYBOARD_INPUT_INDEX_DICTIONARY[@]}; do
          local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"

          if "${OUTPUT_EVENT_PATHS}"; then
            file1_cgroups_output+=( "    \"/dev/input/${event_device}\"," )
          else
            file1_cgroups_output+=( "    \"/dev/input/by-id/${input_device}\"," )
          fi
        done

        for input_device in ${!MOUSE_INPUT_INDEX_DICTIONARY[@]}; do
          local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"

          if "${OUTPUT_EVENT_PATHS}"; then
            file1_cgroups_output+=( "    \"/dev/input/${event_device}\"," )
          else
            file1_cgroups_output+=( "    \"/dev/input/by-id/${input_device}\"," )
          fi
        done

        # for input_device in ${!OTHER_INPUT_INDEX_DICTIONARY[@]}; do
        #   local event_device="${ALL_INPUT_EVENT_DICTIONARY["${input_device}"]}"

        #   if "${OUTPUT_EVENT_PATHS}"; then
        #     file1_cgroups_output+=( "    \"/dev/input/${event_device}\"," )
        #   else
        #     file1_cgroups_output+=( "    \"/dev/input/by-id/${input_device}\"," )
        #   fi
        # done
      fi

      file1_output+=(
        ""
        "### Devices ###"
        "cgroup_device_acl = ["
      )

      file2_output+=(
          ""
          "# Evdev"
      )

      local -a file1_default_cgroups_output=(
        "    \"/dev/null\", \"/dev/full\", \"/dev/zero\","
        "    \"/dev/random\", \"/dev/urandom\","
        "    \"/dev/ptmx\", \"/dev/kvm\","
        "    \"/dev/rtc\", \"/dev/hpet\""
      )

      if ! "${UNDO_CHANGES}"; then
        file1_output+=(
          "${file1_cgroups_output[@]}"
          "${file1_default_cgroups_output[@]}"
          "]"
        )

        file2_output+=(
          "/dev/input/* rw,"
          "/dev/input/by-id/* rw,"
        )
      else
        file1_output+=(
          "${file1_default_cgroups_output[@]}"
          "]"
        )

        file2_output+=(
          "#/dev/input/* rw,"
          "#/dev/input/by-id/* rw,"
        )
      fi

      file1_output+=(
        ""
        "nvram = ["
        "    \"/usr/share/OVMF/OVMF_CODE.fd:/usr/share/OVMF/OVMF_VARS.fd\","
        "    \"/usr/share/OVMF/OVMF_CODE.secboot.fd:/usr/share/OVMF/OVMF_VARS.fd\","
        "    \"/usr/share/AAVMF/AAVMF_CODE.fd:/usr/share/AAVMF/AAVMF_VARS.fd\","
        "    \"/usr/share/AAVMF/AAVMF32_CODE.fd:/usr/share/AAVMF/AAVMF32_VARS.fd\""
        "]"
      )

      if ! write_ref_enum_to_file "file1_output" "${QEMU_DEST_PATH}" \
        || ! write_ref_enum_to_file "file2_output" "${APPARMOR_QEMU_DEST_PATH}" \
        || ! restart_service; then
        return 1
      fi
    }

  function main
  {
    if ! is_sudo_user \
      || ! get_options "$@" \
      || ! get_evdev \
      || ! sort_evdev \
      || ! print_evdev \
      || ! prepare_files; then
      return 1
    fi

    if ! write_to_files; then
      print_fail_to_log "Could not generate Evdev setup."
      return 1
    fi
  }

  function is_sudo_user
  {
    if [[ $( whoami ) != "root" ]]; then
      print_error_to_log "User is not sudo or root."
      return 1
    fi
  }
# </functions>

main "$@"
exit "${?}"